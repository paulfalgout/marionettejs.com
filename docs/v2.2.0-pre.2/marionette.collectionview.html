<html>
  <head>
    <title>marionette.collectionview - Marionette.js Docs</title>
    <link rel="stylesheet" href="../../styles/docs.css">
  </head>
  <body>
    <div class="docs">
      <div class="docs__sidebar">
        <select id="version-dropdown">
          
            
              <option value="v2.3.0">v2.3.0</option>
            
          
            
              <option value="v2.3.0-pre">v2.3.0-pre</option>
            
          
            
              <option value="v2.2.2">v2.2.2</option>
            
          
            
              <option value="v2.2.1">v2.2.1</option>
            
          
            
              <option value="v2.2.0">v2.2.0</option>
            
          
            
              <option value="v2.2.0-pre.2" selected="selected">v2.2.0-pre.2</option>
            
          
            
              <option value="v2.2.0-pre">v2.2.0-pre</option>
            
          
            
              <option value="v2.1.0">v2.1.0</option>
            
          
            
              <option value="v2.1.0-pre">v2.1.0-pre</option>
            
          
            
              <option value="v2.0.3">v2.0.3</option>
            
          
            
              <option value="v2.0.2">v2.0.2</option>
            
          
            
              <option value="v2.0.1">v2.0.1</option>
            
          
            
              <option value="v2.0.0">v2.0.0</option>
            
          
            
              <option value="v2.0.0-pre.2">v2.0.0-pre.2</option>
            
          
            
              <option value="v2.0.0-pre.1">v2.0.0-pre.1</option>
            
          
            
              <option value="v1.8.8">v1.8.8</option>
            
          
            
              <option value="v1.8.7">v1.8.7</option>
            
          
            
              <option value="v1.8.6">v1.8.6</option>
            
          
            
              <option value="v1.8.5">v1.8.5</option>
            
          
            
              <option value="v1.8.4">v1.8.4</option>
            
          
            
              <option value="v1.8.3">v1.8.3</option>
            
          
            
              <option value="v1.8.2">v1.8.2</option>
            
          
            
              <option value="v1.8.1">v1.8.1</option>
            
          
            
              <option value="v1.8.0">v1.8.0</option>
            
          
            
              <option value="v1.7.4">v1.7.4</option>
            
          
            
              <option value="v1.7.3">v1.7.3</option>
            
          
            
              <option value="v1.7.2">v1.7.2</option>
            
          
            
              <option value="v1.7.1">v1.7.1</option>
            
          
            
              <option value="v1.7">v1.7</option>
            
          
            
              <option value="v1.6.4">v1.6.4</option>
            
          
            
              <option value="v1.6.3">v1.6.3</option>
            
          
            
              <option value="v1.6.2">v1.6.2</option>
            
          
            
              <option value="v1.6.1">v1.6.1</option>
            
          
            
              <option value="v1.6.0">v1.6.0</option>
            
          
            
              <option value="v1.5.1">v1.5.1</option>
            
          
            
              <option value="v1.5.0">v1.5.0</option>
            
          
            
              <option value="v1.4.1">v1.4.1</option>
            
          
            
              <option value="v1.4.0">v1.4.0</option>
            
          
            
              <option value="v1.4.0beta">v1.4.0beta</option>
            
          
            
              <option value="v1.3.0">v1.3.0</option>
            
          
            
              <option value="v1.2.3">v1.2.3</option>
            
          
            
              <option value="v1.2.2">v1.2.2</option>
            
          
            
              <option value="v1.2.1">v1.2.1</option>
            
          
            
              <option value="v1.2.0">v1.2.0</option>
            
          
            
              <option value="v1.1.0">v1.1.0</option>
            
          
            
              <option value="v1.0.4">v1.0.4</option>
            
          
            
              <option value="v1.0.3">v1.0.3</option>
            
          
            
              <option value="v1.0.2">v1.0.2</option>
            
          
            
              <option value="v1.0.1">v1.0.1</option>
            
          
            
              <option value="v1.0.0">v1.0.0</option>
            
          
            
              <option value="v1.0.0-rc6">v1.0.0-rc6</option>
            
          
            
              <option value="v1.0.0-rc5">v1.0.0-rc5</option>
            
          
            
              <option value="v1.0.0-rc4">v1.0.0-rc4</option>
            
          
            
              <option value="v1.0.0-rc3">v1.0.0-rc3</option>
            
          
            
              <option value="v1.0.0-rc2">v1.0.0-rc2</option>
            
          
            
              <option value="v1.0.0-rc1">v1.0.0-rc1</option>
            
          
            
              <option value="v1.0.0-beta6">v1.0.0-beta6</option>
            
          
            
              <option value="v1.0.0-beta5">v1.0.0-beta5</option>
            
          
            
              <option value="v1.0.0-beta4">v1.0.0-beta4</option>
            
          
            
              <option value="v1.0.0-beta3">v1.0.0-beta3</option>
            
          
            
              <option value="v1.0.0-beta2">v1.0.0-beta2</option>
            
          
            
              <option value="v1.0.0-beta1">v1.0.0-beta1</option>
            
          
            
              <option value="v0.10.2">v0.10.2</option>
            
          
            
              <option value="v0.10.1">v0.10.1</option>
            
          
            
              <option value="v0.10.0">v0.10.0</option>
            
          
            
              <option value="v0.9.13">v0.9.13</option>
            
          
            
              <option value="v0.9.12">v0.9.12</option>
            
          
            
              <option value="v0.9.11">v0.9.11</option>
            
          
            
              <option value="v0.9.10">v0.9.10</option>
            
          
            
              <option value="v0.9.9">v0.9.9</option>
            
          
            
              <option value="v0.9.8">v0.9.8</option>
            
          
            
              <option value="v0.9.7">v0.9.7</option>
            
          
            
              <option value="v0.9.6">v0.9.6</option>
            
          
            
              <option value="v0.9.5">v0.9.5</option>
            
          
            
              <option value="v0.9.4">v0.9.4</option>
            
          
            
              <option value="v0.9.3">v0.9.3</option>
            
          
            
              <option value="v0.9.2">v0.9.2</option>
            
          
            
              <option value="v0.9.1">v0.9.1</option>
            
          
            
              <option value="v0.9.0">v0.9.0</option>
            
          
            
              <option value="v0.8.4">v0.8.4</option>
            
          
            
              <option value="v0.8.3">v0.8.3</option>
            
          
            
              <option value="v0.8.2">v0.8.2</option>
            
          
            
              <option value="v0.8.1">v0.8.1</option>
            
          
            
              <option value="v0.8.0">v0.8.0</option>
            
          
            
              <option value="v0.7.6">v0.7.6</option>
            
          
            
              <option value="v0.7.5">v0.7.5</option>
            
          
            
              <option value="v0.7.4">v0.7.4</option>
            
          
            
              <option value="v0.7.3">v0.7.3</option>
            
          
            
              <option value="v0.7.2">v0.7.2</option>
            
          
            
              <option value="v0.7.1">v0.7.1</option>
            
          
            
              <option value="v0.7.0">v0.7.0</option>
            
          
            
              <option value="v0.6.3">v0.6.3</option>
            
          
            
              <option value="v0.6.2">v0.6.2</option>
            
          
            
              <option value="v0.6.1">v0.6.1</option>
            
          
            
              <option value="v0.6.0">v0.6.0</option>
            
          
            
              <option value="v0.5.2">v0.5.2</option>
            
          
            
              <option value="v0.5.1">v0.5.1</option>
            
          
            
              <option value="v0.5.0">v0.5.0</option>
            
          
            
              <option value="v0.4.8">v0.4.8</option>
            
          
            
              <option value="v0.4.7">v0.4.7</option>
            
          
            
              <option value="v0.4.6">v0.4.6</option>
            
          
            
              <option value="v0.4.5">v0.4.5</option>
            
          
            
              <option value="v0.4.4">v0.4.4</option>
            
          
            
              <option value="v0.4.3">v0.4.3</option>
            
          
            
              <option value="v0.4.2">v0.4.2</option>
            
          
            
              <option value="v0.4.1">v0.4.1</option>
            
          
            
              <option value="v0.4.1a">v0.4.1a</option>
            
          
            
              <option value="v0.4.0">v0.4.0</option>
            
          
            
              <option value="v0.3.1">v0.3.1</option>
            
          
            
              <option value="v0.3.0">v0.3.0</option>
            
          
            
              <option value="v0.2.6">v0.2.6</option>
            
          
            
              <option value="v0.2.5">v0.2.5</option>
            
          
            
              <option value="v0.2.4">v0.2.4</option>
            
          
            
              <option value="v0.2.3">v0.2.3</option>
            
          
            
              <option value="v0.2.2">v0.2.2</option>
            
          
            
              <option value="v0.2.1">v0.2.1</option>
            
          
            
              <option value="v0.2.0">v0.2.0</option>
            
          
            
              <option value="v0.1.0">v0.1.0</option>
            
          
        </select>
        <nav>
          
            <a href="marionette.application.html">marionette.application</a>
          
            <a href="marionette.approuter.html">marionette.approuter</a>
          
            <a href="marionette.behavior.html">marionette.behavior</a>
          
            <a href="marionette.behaviors.html">marionette.behaviors</a>
          
            <a href="marionette.callbacks.html">marionette.callbacks</a>
          
            <a href="marionette.collectionview.html">marionette.collectionview</a>
          
            <a href="marionette.compositeview.html">marionette.compositeview</a>
          
            <a href="marionette.configuration.html">marionette.configuration</a>
          
            <a href="marionette.controller.html">marionette.controller</a>
          
            <a href="marionette.functions.html">marionette.functions</a>
          
            <a href="marionette.itemview.html">marionette.itemview</a>
          
            <a href="marionette.layoutview.html">marionette.layoutview</a>
          
            <a href="marionette.module.html">marionette.module</a>
          
            <a href="marionette.object.html">marionette.object</a>
          
            <a href="marionette.region.html">marionette.region</a>
          
            <a href="marionette.regionmanager.html">marionette.regionmanager</a>
          
            <a href="marionette.renderer.html">marionette.renderer</a>
          
            <a href="marionette.templatecache.html">marionette.templatecache</a>
          
            <a href="marionette.view.html">marionette.view</a>
          
        </nav>
      </div>
      <div class="docs__content">
        
<h1>Marionette.CollectionView</h1>
<p>The <code>CollectionView</code> will loop through all of the models in the<br />specified collection, render each of them using a specified <code>childView</code>,<br />then append the results of the child view&#39;s <code>el</code> to the collection view&#39;s<br /><code>el</code>. By default the <code>CollectionView</code> will maintain a sorted collection&#39;s order<br />in the DOM. This behavior can be disabled by specifying <code>{sort: false}</code> on initialize.</p><p>CollectionView extends directly from Marionette.View. Please see<br /><a href="marionette.view.md">the Marionette.View documentation</a><br />for more information on available features and functionality.</p><p>Additionally, interactions with Marionette.Region<br />will provide features such as <code>onShow</code> callbacks, etc. Please see<br /><a href="marionette.region.md">the Region documentation</a> for more information.</p><h2>Documentation Index</h2>
<ul>
<li><a href="#collectionviews-childview">CollectionView&#39;s <code>childView</code></a><ul>
<li><a href="#collectionviews-getchildview">CollectionView&#39;s <code>getChildView</code></a></li>
<li><a href="#collectionviews-childviewoptions">CollectionView&#39;s <code>childViewOptions</code></a></li>
<li><a href="#collectionviews-childvieweventprefix">CollectionView&#39;s <code>childViewEventPrefix</code></a></li>
<li><a href="#collectionviews-childevents">CollectionView&#39;s <code>childEvents</code></a></li>
<li><a href="#collectionviews-buildchildview">CollectionView&#39;s <code>buildChildView</code></a></li>
<li><a href="#collectionviews-addchild">CollectionView&#39;s <code>addChild</code></a></li>
</ul>
</li>
<li><a href="#collectionviews-emptyview">CollectionView&#39;s <code>emptyView</code></a><ul>
<li><a href="#collectionviews-getemptyview">CollectionView&#39;s <code>getEmptyView</code></a></li>
<li><a href="#collectionviews-emptyviewoptions">CollectionView&#39;s <code>emptyViewOptions</code></a></li>
</ul>
</li>
<li><a href="#callback-methods">Callback Methods</a><ul>
<li><a href="#onbeforerender-callback">onBeforeRender callback</a></li>
<li><a href="#onrender-callback">onRender callback</a></li>
<li><a href="#beforedestroy-callback">onBeforeDestroy callback</a></li>
<li><a href="#ondestroy-callback">onDestroy callback</a></li>
<li><a href="#onbeforeaddchild-callback">onBeforeAddChild callback</a></li>
<li><a href="#onaddchild-callback">onAddChild callback</a></li>
<li><a href="#onbeforeremovechild-callback">onBeforeRemoveChild callback</a></li>
<li><a href="#onremovechild-callback">onRemoveChild callback</a></li>
</ul>
</li>
<li><a href="#collectionview-events">CollectionView Events</a><ul>
<li><a href="#beforerender-event">&quot;before:render&quot; event</a></li>
<li><a href="#render-event">&quot;render&quot; event</a></li>
<li><a href="#beforedestroy-event">&quot;before:destroy&quot; event</a></li>
<li><a href="#destroy--destroycollection-event">&quot;destroy&quot; / &quot;destroy:collection&quot; event</a></li>
<li><a href="#beforeaddchild--addchild-event">&quot;before:add:child&quot; / &quot;add:child&quot; event</a></li>
<li><a href="#beforeremovechild-event">&quot;before:remove:child event</a></li>
<li><a href="#removechild-event">&quot;remove:child&quot; event</a></li>
<li><a href="#childview-event-bubbling-from-child-views">&quot;childview:*&quot; event bubbling from child views</a></li>
</ul>
</li>
<li><a href="#collectionview-render">CollectionView render</a></li>
<li><a href="#collectionview-automatic-rendering">CollectionView: Automatic Rendering</a></li>
<li><a href="#collectionview-re-render-collection">CollectionView: Re-render Collection</a></li>
<li><a href="#collectionviews-attachhtml">CollectionView&#39;s attachHtml</a></li>
<li><a href="#collectionviews-resortview">CollectionView&#39;s resortView</a></li>
<li><a href="#collectionviews-children">CollectionView&#39;s children</a></li>
<li><a href="#collectionview-destroy">CollectionView destroy</a></li>
</ul>
<h2>CollectionView&#39;s <code>childView</code></h2>
<p>Specify a <code>childView</code> in your collection view definition. This must be<br />a Backbone view object definition, not an instance. It can be any<br /><code>Backbone.View</code> or be derived from <code>Marionette.ItemView</code>.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyChildView = Backbone.Marionette.ItemView.extend({});

Backbone.Marionette.CollectionView.extend({
  childView: MyChildView
});
</code></pre>
<p>Child views must be defined before they are referenced by the<br /><code>childView</code> attribute in a collection view definition. Use <code>getChildView</code><br />to lookup the definition as child views are instantiated.</p><p>Alternatively, you can specify a <code>childView</code> in the options for<br />the constructor:</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyCollectionView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">new</span> MyCollectionView({
  childView: MyChildView
});
</code></pre>
<p>If you do not specify a <code>childView</code>, an exception will be thrown<br />stating that you must specify a <code>childView</code>.</p><h3>CollectionView&#39;s <code>getChildView</code></h3>
<p>The value returned by this method is the <code>ChildView</code> class that will be instantiated when a <code>Model</code> needs to be initially rendered.<br />This method also gives you the ability to customize per <code>Model</code> <code>ChildViews</code>.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> FooBar = Backbone.Model.extend({
  defaults: {
    isFoo: <span class="hljs-literal">false</span>
  }
});

<span class="hljs-keyword">var</span> FooView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">'#foo-template'</span>
});
<span class="hljs-keyword">var</span> BarView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">'#bar-template'</span>
});

<span class="hljs-keyword">var</span> MyCollectionView = Backbone.Marionette.CollectionView.extend({
  getChildView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> </span>{
    <span class="hljs-comment">// Choose which view class to render,</span>
    <span class="hljs-comment">// depending on the properties of the item model</span>
    <span class="hljs-keyword">if</span>  (item.get(<span class="hljs-string">'isFoo'</span>)) {
      <span class="hljs-keyword">return</span> FooView;
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> BarView;
    }
  }
});

<span class="hljs-keyword">var</span> collectionView = <span class="hljs-keyword">new</span> MyCollectionView();
<span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> FooBar({
  isFoo: <span class="hljs-literal">true</span>
});
<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> FooBar({
  isFoo: <span class="hljs-literal">false</span>
});

<span class="hljs-comment">// Renders a FooView</span>
collectionView.collection.add(foo);

<span class="hljs-comment">// Renders a BarView</span>
collectionView.collection.add(bar);
</code></pre>
<h3>CollectionView&#39;s <code>childViewOptions</code></h3>
<p>There may be scenarios where you need to pass data from your parent<br />collection view in to each of the childView instances. To do this, provide<br />a <code>childViewOptions</code> definition on your collection view as an object<br />literal. This will be passed to the constructor of your childView as part<br />of the <code>options</code>.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> ChildView = Backbone.Marionette.ItemView.extend({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> </span>{
    <span class="hljs-built_in">console</span>.log(options.foo); <span class="hljs-comment">// =&gt; "bar"</span>
  }
});

<span class="hljs-keyword">var</span> CollectionView = Backbone.Marionette.CollectionView.extend({
  childView: ChildView,

  childViewOptions: {
    foo: <span class="hljs-string">"bar"</span>
  }
});
</code></pre>
<p>You can also specify the <code>childViewOptions</code> as a function, if you need to<br />calculate the values to return at runtime. The model will be passed into<br />the function should you need access to it when calculating<br /><code>childViewOptions</code>. The function must return an object, and the attributes<br />of the object will be copied to the <code>childView</code> instance&#39;s options.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> CollectionView = Backbone.Marionette.CollectionView.extend({
  childViewOptions: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(model, index)</span> </span>{
    <span class="hljs-comment">// do some calculations based on the model</span>
    <span class="hljs-keyword">return</span> {
      foo: <span class="hljs-string">"bar"</span>,
      childIndex: index
    }
  }
});
</code></pre>
<h3>CollectionView&#39;s <code>childViewEventPrefix</code></h3>
<p>You can customize the event prefix for events that are forwarded<br />through the collection view. To do this, set the <code>childViewEventPrefix</code><br />on the collection view.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> CV = Marionette.CollectionView.extend({
  childViewEventPrefix: <span class="hljs-string">"some:prefix"</span>
});

<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> CV({
  collection: myCol
});

c.on(<span class="hljs-string">"some:prefix:render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">// child view was rendered</span>
});

c.render();
</code></pre>
<p>The <code>childViewEventPrefix</code> can be provided in the view definition or<br />in the constructor function call, to get a view instance.</p><h3>CollectionView&#39;s <code>childEvents</code></h3>
<p>You can specify a <code>childEvents</code> hash or method which allows you to capture all bubbling childEvents without having to manually set bindings. The keys of the hash can either be a function or a string that is the name of a method on the collection view.</p><pre><code class="lang-js"><span class="hljs-comment">// childEvents can be specified as a hash...</span>
<span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({

  <span class="hljs-comment">// This callback will be called whenever a child is rendered or emits a `render` event</span>
  childEvents: {
    render: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a childView has been rendered"</span>);
    }
  }
});

<span class="hljs-comment">// ...or as a function that returns a hash.</span>
<span class="hljs-keyword">var</span> MyCollectionView = Marionette.CollectionView.extend({

  childEvents: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> {
      render: <span class="hljs-keyword">this</span>.onChildRendered
    }
});
</code></pre>
<p>This also works for custom events that you might fire on your child views.</p><pre><code class="lang-js"><span class="hljs-comment">// The child view fires a custom event, `show:message`</span>
<span class="hljs-keyword">var</span> ChildView = <span class="hljs-keyword">new</span> Marionette.ItemView.extend({
  events: {
    <span class="hljs-string">'click .button'</span>: <span class="hljs-string">'showMessage'</span>
  },

  showMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The button was clicked.'</span>);

    <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'show:message'</span>);
  }
});

<span class="hljs-comment">// The parent uses childEvents to catch that custom event on the child view</span>
<span class="hljs-keyword">var</span> ParentView = <span class="hljs-keyword">new</span> Marionette.CollectionView.extend({
  childView: ChildView,

  childEvents: {
    <span class="hljs-string">'show:message'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The show:message event bubbled up to the parent.'</span>);
    }
  }
});
</code></pre>
<h3>CollectionView&#39;s <code>buildChildView</code></h3>
<p>When a custom view instance needs to be created for the <code>childView</code> that<br />represents a child, override the <code>buildChildView</code> method. This method<br />takes three parameters and returns a view instance to be used as the<br />child view.</p><pre><code class="lang-js">buildChildView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, ChildViewClass, childViewOptions)</span></span>{
  <span class="hljs-comment">// build the final list of options for the childView class</span>
  <span class="hljs-keyword">var</span> options = _.extend({model: child}, childViewOptions);
  <span class="hljs-comment">// create the child view instance</span>
  <span class="hljs-keyword">var</span> view = <span class="hljs-keyword">new</span> ChildViewClass(options);
  <span class="hljs-comment">// return it</span>
  <span class="hljs-keyword">return</span> view;
},
</code></pre>
<h3>CollectionView&#39;s <code>addChild</code></h3>
<p>The <code>addChild</code> method is responsible for rendering the <code>childViews</code> and adding them to the HTML for the <code>collectionView</code> instance. It is also responsible for triggering the events per <code>ChildView</code>. In most cases you should not override this method. However if you do want to short circut this method, it can be accomplished via the following.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  addChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, ChildView, index)</span></span>{
    <span class="hljs-keyword">if</span> (child.shouldBeShown()) {
      Backbone.Marionette.CollectionView.prototype.addChild.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }
  }
});
</code></pre>
<h2>CollectionView&#39;s <code>emptyView</code></h2>
<p>When a collection has no children, and you need to render a view other than<br />the list of childViews, you can specify an <code>emptyView</code> attribute on your<br />collection view.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> NoChildsView = Backbone.Marionette.ItemView.extend({
  template: <span class="hljs-string">"#show-no-children-message-template"</span>
});

Backbone.Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  emptyView: NoChildsView
});
</code></pre>
<h3>CollectionView&#39;s <code>getEmptyView</code></h3>
<p>If you need the <code>emptyView</code>&#39;s class chosen dynamically, specify <code>getEmptyView</code>:</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  getEmptyView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// custom logic</span>
    <span class="hljs-keyword">return</span> NoChildsView;
  }
</code></pre>
<p>This will render the <code>emptyView</code> and display the message that needs to<br />be displayed when there are no children.</p><p>If you want to control when the empty view is rendered, you can override<br /><code>isEmpty</code>:</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  isEmpty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collection)</span> </span>{
    <span class="hljs-comment">// some logic to calculate if the view should be rendered as empty</span>
    <span class="hljs-keyword">return</span> someBoolean;
  }
});
</code></pre>
<h3>CollectionView&#39;s <code>emptyViewOptions</code></h3>
<p>Similar to <code>childView</code> and <code>childViewOptions</code>, there is an <code>emptyViewOptions</code> property that will be passed to the <code>emptyView</code> constructor. It can be provided as an object literal or as a function.</p><p>If <code>emptyViewOptions</code> aren&#39;t provided the CollectionView will default to passing the <code>childViewOptions</code> to the <code>emptyView</code>.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> EmptyView = Backbone.Marionette.ItemView({
  initialize: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span></span>{
    <span class="hljs-built_in">console</span>.log(options.foo); <span class="hljs-comment">// =&gt; "bar"</span>
  }
});

<span class="hljs-keyword">var</span> CollectionView = Backbone.Marionette.CollectionView({
  emptyView: EmptyView,

  emptyViewOptions: {
    foo: <span class="hljs-string">"bar"</span>
  }
});
</code></pre>
<h2>Callback Methods</h2>
<p>There are several callback methods that can be provided on a<br /><code>CollectionView</code>. If they are found, they will be called by the<br />view&#39;s base methods. These callback methods are intended to be<br />handled within the view definition directly.</p><h3>onBeforeRender callback</h3>
<p>A <code>onBeforeRender</code> callback will be called just prior to rendering<br />the collection view.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeRender: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3>onRender callback</h3>
<p>After the view has been rendered, a <code>onRender</code> method will be called.<br />You can implement this in your view to provide custom code for dealing<br />with the view&#39;s <code>el</code> after it has been rendered:</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onRender: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3>onBeforeDestroy callback</h3>
<p>This method is called just before destroying the view.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3>onDestroy callback</h3>
<p>This method is called just after destroying the view.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// do stuff here</span>
  }
});
</code></pre>
<h3>onBeforeAddChild callback</h3>
<p>This callback function allows you to know when a child / child view<br />instance is about to be added to the collection view. It provides access to<br />the view instance for the child that was added.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</code></pre>
<h3>onAddChild callback</h3>
<p>This callback function allows you to know when a child / child view<br />instance has been added to the collection view. It provides access to<br />the view instance for the child that was added.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</code></pre>
<h3>onBeforeRemoveChild callback</h3>
<p>This callback function allows you to know when a <code>childView</code><br />instance is about to be removed from the <code>collectionView</code>. It provides access to<br />the view instance for the child that was removed.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onBeforeRemoveChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</code></pre>
<h3>onRemoveChild callback</h3>
<p>This callback function allows you to know when a child / childView<br />instance has been deleted or removed from the<br />collection.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onRemoveChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
    <span class="hljs-comment">// work with the childView instance, here</span>
  }
});
</code></pre>
<h2>CollectionView Events</h2>
<p>There are several events that will be triggered during the life<br />of a collection view. Each of these events is called with the<br /><a href="./marionette.functions.md">Marionette.triggerMethod</a> function,<br />which calls a corresponding &quot;on{EventName}&quot; method on the<br />view instance (see <a href="#callback-methods">above</a>).</p><h3>&quot;before:render&quot; event</h3>
<p>Triggers just prior to the view being rendered. Also triggered as<br />&quot;collection:before:render&quot; / <code>onCollectionBeforeRender</code>.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"before:render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be rendered"</span>);
});

myView.render();
</code></pre>
<h3>&quot;render&quot; event</h3>
<p>A &quot;collection:rendered&quot; / <code>onCollectionRendered</code> event will also be fired. This allows you to<br />add more than one callback to execute after the view is rendered,<br />and allows parent views and other parts of the application to<br />know that the view was rendered.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"render"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view was rendered!"</span>);
});

myView.on(<span class="hljs-string">"collection:rendered"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view was rendered!"</span>);
});

myView.render();
</code></pre>
<h3>&quot;before:destroy&quot; event</h3>
<p>Triggered just before destroying the view. A &quot;before:destroy:collection&quot; /<br /><code>onBeforeDestroyCollection</code> event will also be fired</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"before:destroy:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is about to be destroyed"</span>);
});

myView.destroy();
</code></pre>
<h3>&quot;destroy&quot; / &quot;destroy:collection&quot; event</h3>
<p>Triggered just after destroying the view, both with corresponding<br />method calls.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-keyword">var</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.on(<span class="hljs-string">"destroy:collection"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  alert(<span class="hljs-string">"the collection view is now destroyed"</span>);
});

myView.destroy();
</code></pre>
<h3>&quot;before:add:child&quot; / &quot;add:child&quot; event</h3>
<p>The &quot;before:add:child&quot; event and corresponding <code>onBeforeAddChild</code><br />method are triggered just after creating a new <code>childView</code> instance for<br />a child that was added to the collection, but before the<br />view is rendered and added to the DOM.</p><p>The &quot;add:child&quot; event and corresponding <code>onAddChild</code><br />method are triggered after rendering the view and adding it to the<br />view&#39;s DOM element.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyCV = Marionette.CollectionView.extend({
  <span class="hljs-comment">// ...</span>

  onBeforeAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// ...</span>
  },

  onAddChild: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// ...</span>
  }
});

<span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> MyCV({...});

cv.on(<span class="hljs-string">"before:add:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});

cv.on(<span class="hljs-string">"add:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3>&quot;before:remove:child&quot;</h3>
<p>This is triggered after the childView instance has been<br />removed from the collection, but before it has been destroyed.</p><pre><code class="lang-js">cv.on(<span class="hljs-string">"before:remove:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3>&quot;remove:child&quot; event</h3>
<p>Triggered after a childView instance has been destroyed and<br />removed, when its child was deleted or removed from the<br />collection.</p><pre><code class="lang-js">cv.on(<span class="hljs-string">"remove:child"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(viewInstance)</span></span>{
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h3>&quot;childview:*&quot; event bubbling from child views</h3>
<p>When a child view within a collection view triggers an<br />event, that event will bubble up through the parent<br />collection view with &quot;childview:&quot; prepended to the event<br />name.</p><p>That is, if a child view triggers &quot;do:something&quot;, the<br />parent collection view will then trigger &quot;childview:do:something&quot;.</p><pre><code class="lang-js"><span class="hljs-comment">// set up basic collection</span>
<span class="hljs-keyword">var</span> myModel = <span class="hljs-keyword">new</span> MyModel();
<span class="hljs-keyword">var</span> myCollection = <span class="hljs-keyword">new</span> MyCollection();
myCollection.add(myModel);

<span class="hljs-comment">// get the collection view in place</span>
<span class="hljs-keyword">var</span> colView = <span class="hljs-keyword">new</span> CollectionView({
  collection: myCollection,
  childView: MyItemView
});
colView.render();

<span class="hljs-comment">// bind to the collection view's events that were bubbled</span>
<span class="hljs-comment">// from the child view</span>
colView.on(<span class="hljs-string">"childview:do:something"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childView, msg)</span></span>{
  alert(<span class="hljs-string">"I said, '"</span> + msg + <span class="hljs-string">"'"</span>);
});

<span class="hljs-comment">// hack, to get the child view and trigger from it</span>
<span class="hljs-keyword">var</span> childView = colView.children[myModel.cid];
childView.trigger(<span class="hljs-string">"do:something"</span>, <span class="hljs-string">"do something!"</span>);
</code></pre>
<p>The result of this will be an alert box that says<br />&quot;I said, &#39;do something!&#39;&quot;.</p><p>Also note that you would not normally grab a reference to<br />the child view the way this is showing. I&#39;m merely using<br />that hack as a way to demonstrate the event bubbling.<br />Normally, you would have your child view listening to DOM<br />events or model change events, and then triggering an event<br />of its own based on that.</p><h2>CollectionView render</h2>
<p>The <code>render</code> method of the collection view is responsible for<br />rendering the entire collection. It loops through each of the<br />children in the collection and renders them individually as an<br /><code>childView</code>.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> MyCollectionView = Backbone.Marionette.CollectionView.extend({...});

<span class="hljs-comment">// all of the children views will now be rendered.</span>
<span class="hljs-keyword">new</span> MyCollectionView().render();
</code></pre>
<h2>CollectionView: Automatic Rendering</h2>
<p>The collection view binds to the &quot;add&quot;, &quot;remove&quot; and &quot;reset&quot; events of the<br />collection that is specified.</p><p>When the collection for the view is &quot;reset&quot;, the view will call <code>render</code> on<br />itself and re-render the entire collection.</p><p>When a model is added to the collection, the collection view will render that<br />one model in to the collection of child views.</p><p>When a model is removed from a collection (or destroyed / deleted), the collection<br />view will destroy and remove that model&#39;s child view.</p><h2>CollectionView: Re-render Collection</h2>
<p>If you need to re-render the entire collection, you can call the<br /><code>view.render</code> method. This method takes care of destroying all of<br />the child views that may have previously been opened.</p><h2>CollectionView&#39;s attachHtml</h2>
<p>By default the collection view will append the HTML of each ChildView<br />into the element buffer, and then call jQuery&#39;s <code>.append</code> once at the<br />end to move the HTML into the collection view&#39;s <code>el</code>.</p><p>You can override this by specifying an <code>attachHtml</code> method in your<br />view definition. This method takes three parameters and has no return<br />value.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({

    <span class="hljs-comment">// The default implementation:</span>
  attachHtml: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collectionView, childView, index)</span></span>{
    <span class="hljs-keyword">if</span> (collectionView.isBuffering) {
      <span class="hljs-comment">// buffering happens on reset events and initial renders</span>
      <span class="hljs-comment">// in order to reduce the number of inserts into the</span>
      <span class="hljs-comment">// document, which are expensive.</span>
      collectionView.elBuffer.appendChild(childView.el);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// If we've already rendered the main collection, just</span>
      <span class="hljs-comment">// append the new children directly into the element.</span>
      collectionView.$el.append(childView.el);
    }
  },

  <span class="hljs-comment">// Called after all children have been appended into the elBuffer</span>
  attachBuffer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(collectionView, buffer)</span> </span>{
    collectionView.$el.append(buffer);
  },

  <span class="hljs-comment">// called on initialize and after attachBuffer is called</span>
  initRenderBuffer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">this</span>.elBuffer = <span class="hljs-built_in">document</span>.createDocumentFragment();
  }

});
</code></pre>
<p>The first parameter is the instance of the collection view that<br />will receive the HTML from the second parameter, the current child<br />view instance.</p><p>The third parameter, <code>index</code>, is the index of the<br />model that this <code>childView</code> instance represents, in the collection<br />that the model came from. This is useful for sorting a collection<br />and displaying the sorted list in the correct order on the screen.</p><p>Overrides of <code>attachHtml</code> that don&#39;t take into account the element<br />buffer will work fine, but won&#39;t take advantage of the 60x performance<br />increase the buffer provides.</p><h2>CollectionView&#39;s resortView</h2>
<p>By default the <code>CollectionView</code> will maintain the order of its <code>collection</code><br />in the DOM. However on occasions the view may need to re-render to make this<br />possible, for example if you were to change the comparator on the collection.<br />By default <code>CollectionView</code> will call <code>render</code> when this happens, but there are<br />cases where this may not be suitable. For instance when sorting the <code>children</code><br />in a <code>CompositeView</code>, you want to only render the internal collection.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
  collection: someCollection,
  resortView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// provide custom logic for rendering after sorting the collection</span>
  }
});
</code></pre>
<h2>CollectionView&#39;s children</h2>
<p>The CollectionView uses <a href="https://github.com/marionettejs/backbone.babysitter">Backbone.BabySitter</a><br />to store and manage its child views. This allows you to easily access<br />the views within the collection view, iterate them, find them by<br />a given indexer such as the view&#39;s model or collection, and more.</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> cv = <span class="hljs-keyword">new</span> Marionette.CollectionView({
  collection: someCollection
});

cv.render();


<span class="hljs-comment">// retrieve a view by model</span>
<span class="hljs-keyword">var</span> v = cv.children.findByModel(someModel);

<span class="hljs-comment">// iterate over all of the views and process them</span>
cv.children.each(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span></span>{

  <span class="hljs-comment">// process the `view` here</span>

});
</code></pre>
<p>For more information on the available features and functionality of<br />the <code>.children</code>, see the <a href="https://github.com/marionettejs/backbone.babysitter">Backbone.BabySitter documentation</a>.</p><h2>CollectionView destroy</h2>
<p>CollectionView implements a <code>destroy</code> method, which is called by the<br />region managers automatically. As part of the implementation, the<br />following are performed:</p><ul>
<li>unbind all <code>listenTo</code> events</li>
<li>unbind all custom view events</li>
<li>unbind all DOM events</li>
<li>unbind all child views that were rendered</li>
<li>remove <code>this.el</code> from the DOM</li>
<li>call an <code>onDestroy</code> event on the view, if one is provided</li>
</ul>
<p>By providing an <code>onDestroy</code> event in your view definition, you can<br />run custom code for your view that is fired after your view has been<br />destroyed and cleaned up. This lets you handle any additional clean up<br />code without having to override the <code>destroy</code> method.</p><pre><code class="lang-js">Backbone.Marionette.CollectionView.extend({
  onDestroy: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// custom cleanup or destroying code, here</span>
  }
});
</code></pre>

      </div>
    </div>
  </body>
  <script src="../../js/docs.js" type="text/javascript"></script>
</html>
